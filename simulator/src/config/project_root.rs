use std::ffi::OsString;
use std::path::PathBuf;

use crate::backend::Helm;

/// Essential file layout:
/// ```
/// ./ - git project root, contains common configs for node run
/// ├── config.json - node config template, will be patched and used by every pod
/// ├── keys.json - keypair for minter and global config, added into final zerostate
/// ├── logger.json - used by every pod
/// ├── zerostate.json - initial BC state template
/// ├── base.Dockerfile - rocksdb image on which `tycho` depends
/// ├── tycho.Dockerfile - runnable image
/// ├── .temp/ - contains files generated by `gen-network.sh`
/// │   ├── global-config.json - used as a donor of zerostate hash, bootstrap peers are replaced
/// │   ├── zerostate.json - patched zerostate that is encoded into BOC, has default mempool config
/// │   ├── zerostate.boc
/// │   ├── keys{N}.json - used to rewrite global config addresses, leaving zerostate.boc untouched
/// │   └── config{N}.json - ignored
/// └── simulator/
///     └── helm/ - templates for `simulator prepare` command
///        ├── build/ - chart to build image in a remote k8s
///        │  └── values.yaml - created by `simulator prepare`, not overwritable
///        └── tycho/ - simulator chart
///           └── values.yaml - created by `simulator prepare`, overwritable
/// ```
#[derive(Debug, Clone)]
pub struct ProjectRoot {
    pub dir: OsString,
    pub temp: TempDir,
    pub simulator: SimulatorDir,
    pub config: OsString,
    pub logger: OsString,
    pub base_dockerfile: OsString,
    pub tycho_dockerfile: OsString,
}

impl ProjectRoot {
    pub fn new() -> Result<Self, std::io::Error> {
        let project_root = tycho_util::project_root()?;

        let helm_dir = project_root.join("simulator").join("helm");
        let helm_builder_dir = helm_dir.join(Helm::BUILDER_CHART.0);
        let helm_tycho_dir = helm_dir.join(Helm::TYCHO_CHART.0);

        let simulator_dir = SimulatorDir {
            helm: HelmDir {
                builder: HelmBuildDir {
                    values: helm_builder_dir.join("values.yaml").into(),
                    dir: helm_builder_dir.into(),
                },
                tycho: HelmTychoDir {
                    values: helm_tycho_dir.join("values.yaml").into(),
                    dir: helm_tycho_dir.into(),
                },
                dir: helm_dir.into(),
            },
        };

        let temp_dir = project_root.join(".temp");
        let temp_dir = TempDir {
            global_config: temp_dir.join("global-config.json").into(),
            zerostate_boc: temp_dir.join("zerostate.boc").into(),
            zerostate_json: temp_dir.join("zerostate.json").into(),
            dir: temp_dir,
        };

        Ok(ProjectRoot {
            temp: temp_dir,
            simulator: simulator_dir,
            config: project_root.join("config.json").into(),
            logger: project_root.join("logger.json").into(),
            base_dockerfile: project_root.join("base.Dockerfile").into(),
            tycho_dockerfile: project_root.join("tycho.Dockerfile").into(),
            dir: project_root.into(),
        })
    }
}

#[derive(Debug, Clone)]
pub struct SimulatorDir {
    pub helm: HelmDir,
}

#[derive(Debug, Clone)]
pub struct HelmDir {
    pub dir: OsString,
    pub builder: HelmBuildDir,
    pub tycho: HelmTychoDir,
}

#[derive(Debug, Clone)]
pub struct HelmBuildDir {
    pub dir: OsString,
    pub values: OsString,
}

#[derive(Debug, Clone)]
pub struct HelmTychoDir {
    pub dir: OsString,
    pub values: OsString,
}

#[derive(Debug, Clone)]
pub struct TempDir {
    pub global_config: OsString,
    pub zerostate_boc: OsString,
    pub zerostate_json: OsString,
    dir: PathBuf,
}

impl TempDir {
    pub fn keys(&self, node_index: usize) -> OsString {
        self.dir.join(format!("keys{node_index}.json")).into()
    }
}
